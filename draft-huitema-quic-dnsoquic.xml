<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [

<!ENTITY rfc1034 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1034.xml'>

<!ENTITY rfc1035 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1035.xml'>

<!ENTITY rfc1996 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1996.xml'>

<!ENTITY rfc2119 PUBLIC ''
   'http://xml2rfc.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml'>

<!ENTITY rfc4033 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4033.xml'>

<!ENTITY rfc5936 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5936.xml'>

<!ENTITY rfc6335 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6335.xml'>

<!ENTITY rfc6698 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6698.xml'>

<!ENTITY rfc7120 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7120.xml'>

<!ENTITY rfc7301 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7301.xml'>

<!ENTITY rfc7626 PUBLIC ''  
   "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7626.xml"> 

<!ENTITY rfc7766 PUBLIC ''  
   "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7766.xml"> 

<!ENTITY rfc7828 PUBLIC ''  
   "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7828.xml"> 
 
<!ENTITY rfc7858 PUBLIC ''  
   "http://xml.resource.org/public/rfc/bibxml/reference.RFC.7858.xml"> 

<!ENTITY I-D.ietf-quic-transport PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-quic-transport.xml"> 

<!ENTITY I-D.ietf-quic-recovery PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-quic-recovery.xml"> 

<!ENTITY I-D.ietf-quic-tls PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-quic-tls.xml"> 

<!ENTITY I-D.ietf-quic-http PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-quic-http.xml"> 

<!ENTITY I-D.ietf-dprive-dtls-and-tls-profiles PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dprive-dtls-and-tls-profiles.xml">

<!ENTITY I-D.ietf-dnssd-push PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-dnssd-push.xml">

<!ENTITY I-D.ietf-tls-tls13 PUBLIC ''  
   "http://xml2rfc.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-tls-tls13.xml">


]>

<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc compact="yes"?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>

<!-- Expand crefs and put them inline -->
<?rfc comments='yes' ?>
<?rfc inline='yes' ?>

<rfc category="std" 
     docName="draft-huitema-quic-dnsoquic-00.txt" 
     ipr="trust200902">

<front>
    <title abbrev="DNS over QUIC">
      Specification of DNS over QUIC
    </title>

   <author fullname="Christian Huitema" initials="C." surname="Huitema">
      <organization>Private Octopus Inc.</organization>
      <address>
        <postal>
          <street> </street>
          <city>Friday Harbor</city>
          <code>98250</code>
          <region>WA</region>
          <country>U.S.A.</country>
        </postal>
        <email>huitema@huitema.net</email>
      </address>
    </author>
   <author fullname="Melinda Shore" initials="M." surname="Shore">
      <organization>No Mountain Software</organization>
      <address>
        <postal>
          <street> </street>
          <city></city>
          <country></country>
        </postal>
        <email>melinda.shore@nomountain.net</email>
      </address>
    </author>
   <author fullname="Allison Mankin" initials="A." surname="Mankin">
      <organization>Salesforce</organization>
      <address>
        <postal>
          <street> </street>
          <city></city>
          <country></country>
        </postal>
        <email>amankin@salesforce.com</email>
      </address>
    </author>
   <author fullname="Sara Dickinson" initials="S." surname="Dickinson">
      <organization>Sinodun IT</organization>
      <address>
        <postal>
          <street>Magdalen Centre, Oxford Science Park </street>
          <city>Oxford</city>
          <country>U.K.</country>
        </postal>
        <email>sara@sinodun.com</email>
      </address>
    </author>
    <date year="2017" />

    <abstract>
        <t> 
   This document describes the use of QUIC to
   provide transport privacy for DNS.  The encryption provided by QUIC
   has similar properties to that provided by TLS, while QUIC transport
   eliminates the end-of-queue blocking issues inherent
   with TCP and provides more efficient error corrections than
   UDP. DNS over QUIC has privacy properties similar to DNS over TLS
   specified in RFC 7858, and performance similar to classic
   DNS over UDP.
        </t>
    </abstract>
</front>

<middle>
<section title="Introduction">
<t>
Domain Name System (DNS) concepts are specified in <xref target="RFC1034" />.
This document presents a mapping of the DNS protocol <xref target="RFC1035" /> over QUIC
transport <xref target="I-D.ietf-quic-transport" />. The goals of this mapping
are:
<list style="numbers" >
<t>
Provide the same DNS privacy protection as DNS over TLS <xref target="RFC7858" />.
</t>
<t>
Explore the potential performance gains of using QUIC as a DNS transport, versus other
solutions like QUIC over UDP <xref target="RFC1035" /> or DNS over TLS <xref target="RFC7858" />.
</t>
<t>
Participate in the definition of QUIC protocols and API, by outlining a use case for QUIC
different from HTTP over QUIC <xref target="I-D.ietf-quic-http" />.
</t>
</list>
</t>
<t>
In order to achieve these goals, we will focus on the "stub to recursive resolver" scenario
also addressed by <xref target="RFC7858" />, and we will list specific non-goals:
<list style="numbers" >
<t>
We will not attempt to support zone transfers <xref target="RFC5936" />, as these
are not relevant to the stub to recursive resolver scenario.
</t>
<t>
We will not attempt to evade potential blocking of DNS over QUIC traffic by 
middle boxes.  
</t>
</list>
</t>
<t>
Users interested in zone transfers should continue using TCP based solutions, and 
users interested in evading middle-boxes should consider using solutions like
DNS over HTTPS or DNS over HTTP over QUIC.
</t>
<t>
Specifying the transmission of an application over QUIC requires to specify how 
the application messages are
mapped to QUIC streams, and generally how the application will use QUIC. 
This is done for HTTP in 
<xref target="I-D.ietf-quic-http" />. The 
purpose of this document is to define the way DNS can be transmitted over QUIC.
</t>
<t>
In this document, <xref target="consider-design" /> presents the reasoning that guided our
design. <xref target="DNS-QUIC-spec" /> specifies the actual mapping of DNS over QUIC. 
<xref target="usage-and-deployment" /> presents guidelines on the usage and deployment
of DNS over QUIC.
</t>

<section title="Requirements">
<t>
  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
  document are to be interpreted as described in <xref target="RFC2119" />.
</t>
</section>

</section> <!-- end of introduction -->

<section title="Design Considerations" anchor="consider-design" >
<t>
This section and its subsection present the design guidelines that were used for
the proposed mapping of DNS over QUIC. This section is informative in nature.
</t>
<section title="Focus on the stub to resolver scenario" >
<t>
We can broadly classify the DNS protocol usage scenario in three groups: stub to recursive
resolver, recursive resolver to authoritative, and server to server. 
Our design focuses on the "stub to recursive resolver" scenario, and specifically to
the scenario in which the choice of recursive resolver is manually configured in the
stub. In this case, the configuration will specify the name of the resolver, its address,
how security credentials are verified, and of course the use of QUIC as a transport.
</t>
<t>
We will not address the scenario in which the stub dynamically discovers the resolver
using DHCP or IPv6 Router Advertisements. These scenarios would require a way to dynamically
signal support for QUIC transport in these resolvers. This is left for future study.
</t>
<t>
We will also not address the recursive to authoritative scenarios. Authoritative
resolvers are discovered dynamically through NS records. In the absence of
an agreed way for authoritative to signal support for QUIC transport, recursive
resolvers would have to resort to some trial and error process. At this stage of
QUIC deployment, this would be mostly errors, and does not seem attractive.
This could change in the future.
</t>
<t>
The DNS protocol is also used for zone transfers. In the  
zone transfer scenario (<xref target="RFC5936" />), the client emits a single 
AXFR query, and the server responds with a series of AXFR responses. This creates
a unique profile, in which a query results in several responses. Supporting
that profile would complicate the mapping of DNS queries over QUIC streams.
Zone transfers are not used in the stub to recursive scenario that we focus on,
and seem to be currently well served by the DNS over TCP.
We will not attempt to support them in this proposed mapping of DNS to QUIC.
</t>
</section>
<section title="Meet Privacy Requirements" >
<t>
DNS privacy considerations are described in <xref target="RFC7626"/>.  
<xref target="RFC7858" /> defines how to mitigate these issues by transmitting 
DNS messages over TLS and TCP. QUIC connection setup includes the negotiation 
of security parameters using TLS, as specified in
<xref target="I-D.ietf-quic-tls" />, enabling encryption of the QUIC transport.
Transmitting DNS messages over QUIC will provide the same privacy protections as 
<xref target="RFC7858" />.
</t>
</section>
<section title="Design for minimum latency" anchor="minimum-latency">
<t>
QUIC is specifically designed to reduce the delay between HTTP queries and HTTP
responses. This is achieved through three main components:
<list style="numbers" >
<t>
Support for 0-RTT data during session resume,
</t>
<t>
Support for advanced error recovery procedures as specified in 
<xref target="I-D.ietf-quic-recovery" />.
</t>
<t>
Mitigation of head-of-queue blocking by allowing parallel delivery
of data on multiple streams.
</t>
</list>
</t>
<t>
The mapping of DNS to QUIC will take advantage of these features in three
ways:
<list style="numbers" >
<t>
Optional support for sending 0-RTT data during session resume,
</t>
<t>
Long duration sessions carrying several DNS transactions, generating the
sustained traffic required to benefit from advanced recovery features,
</t>
<t>
Mapping of each DNS Query/Response exchange to a separate stream, to
mitigate head of queue blocking.
</t>
</list>
</t>
<t>
These considerations will be reflected in the mapping of DNS traffic to QUIC 
streams in <xref target="stream-mapping-spec" />.
</t>
</section>
<section title="Development of QUIC protocols and API" anchor="quic-development" >
<t>
QUIC is defined as a layered protocol, with application specific mapping
layered on top of the generic QUIC transport. The only mapping
defined at this stage is HTTP over QUIC <xref target="I-D.ietf-quic-http" />.
Adding a different mapping for a different application contributes to
the development of QUIC. 
</t>
<t>
In the HTTP over QUIC mappings, the stream number 3 is used for control messages,
in which client or server announce their intent to send headers and bodies of
requests and responses and specify the number of the streams that will carry
these headers and response. The
advantage is that client and server can then schedule processing of the requests
and responses according to various policies and priorities, and can tightly 
control the usage of streams. This comes at the cost of some complexity,
and also some performance since the control stream is exposed to head of queue 
blocking.
</t>
<t>
We want to deliberately explore a different design, in which there is no control
stream. Clients and servers can initiate queries as determined by the DNS application
logic, opening new streams as necessary. This provides for maximum parallelism
between queries, as noted in <xref target="minimum-latency" />. It also places
constraints on the API. Instead of merely listening for control messages 
on a control stream, client and servers will have to be notified of the opening
of a new stream by their peer. Instead of orderly closing the control stream, 
client and server will have to use orderly connection closure mechanisms
and manage the potential loss of data if closing on one end conflicts with
opening of a stream on the other end.
</t>
</section>

<section title="No specific middlebox bypass mechanism" >
<t>
Being different from HTTP over QUIC is a design choice. The advantage is that the
mapping can be defined for minimal overhead and maximum performance. The downside
is that the difference can be noted by firewall and middleboxes. There may be
environments in which HTTP over QUIC will be allowed, but DNS over QUIC will
be disallowed and blocked by these middle boxes. 
</t>
<t>
We are conscious that this might be a problem, but we have no indication on how 
widespread that problem might be. It might be that the problem will be so acute
that the only realistic solution would be to communicate with independent
recursive resolvers using DNS over HTTPS, or maybe DNS over HTTP over QUIC. Or
it might be that the problem is rare enough and the performance gains significant
enough that the correct solution is to use DNS over QUIC most of the time,
and to fall back on DNS over HTTPS some of the time. Measurements and
experimentations will inform that decision. In between, we believe that
a clean design is most likely to inform the QUIC development, as explained 
in <xref target="quic-development" />.
</t>
</section>


</section> <!-- end of design -->

<section title="Specifications" anchor="DNS-QUIC-spec" >

<section anchor="connection-establishment" title="Connection Establishment">

<t>DNS/QUIC connections are established as described in 
<xref target="I-D.ietf-quic-transport"/>. During
connection establishment, DNS/QUIC support is indicated by selecting the ALPN
token "dq" in the crypto handshake.</t>

<section title="Draft Version Identification" >

<t><list style='empty'>
  <t><spanx style="strong">RFC Editor's Note:</spanx>  Please 
remove this section prior to publication of a
final version of this document.</t>
</list></t>

<t>Only implementations of the final, published RFC can identify themselves as
"dq". Until such an RFC exists, implementations MUST NOT identify themselves
using this string.</t>

<t>Implementations of draft versions of the protocol MUST add the string "-" and
the corresponding draft number to the identifier. For example,
draft-huitema-quic-dnsoquic-00 is identified using the string "hq-h00".</t>
</section>

<section anchor="port-selection" title="Port Selection">
        <t>
          By default, a DNS server that supports DNS/QUIC MUST listen for
          and accept QUIC connections on UDP port 853, unless it has mutual agreement
          with its clients to use a port other than
          853 for DNS over QUIC.
          In order to use a port other than 853, both clients and servers
          would need a configuration option in their software.
        </t>
        <t>
          By default, a DNS client desiring to use DNS over QUIC with a
          particular server MUST establish a QUIC connection to UDP
          port 953 on the server, unless it has mutual agreement with its server
          to use a port other than port 953 for DNS over QUIC.
          Such another port MUST NOT be port 53 or port 853.
          This recommendation against use of port 53 for DNS over QUIC
	  is to avoid confusion between DNS over QUIC and DNS over UDP
          as specified in <xref target="RFC1035" />.      
          Similarly, using port 853 
	  would cause confusion between DNS over QUIC and DNS over DTLS
          as specified in <xref target="RFC1035" />.      
        </t>
      </section>


     
</section> <!-- end of Connections -->

<section title="Stream Mapping and Usage" anchor="stream-mapping-spec" >
<t>
The mapping of
DNS traffic over QUIC streams takes advantage of the QUIC stream features
detailed in section 10 of <xref target="I-D.ietf-quic-transport" />.
</t>
<t>
The stub to resolver DNS traffic follows a simple pattern in which the
client emits a query, and the server provides a response. 
In this case the
client MUST select the next available client stream, in conformance
with section 10.2 of <xref target="I-D.ietf-quic-transport" />.
</t>
<t>
The client MUST send the DNS query over the selected stream, 
and MUST indicate through the STREAM FIN mechanism that no further data will
be sent on that stream.
</t>
<t>
The server MUST send the response on the same stream, and MUST indicate through the 
STREAM FIN mechanism mechanism that no further data will
be sent on that stream. 
</t> 
<t>
DNS query and responses are formatted as specified in <xref target="RFC1035" />.
In contrast with DNS over TCP <xref target="RFC7766" /> and DNS over TLS <xref target="RFC7858" />, 
these messages are sent without a two bytes length field prepended.
</t>

<section title="Server initiated transactions" >
<t>
There are planned traffic patterns in which a server sends unsolicited queries to a client,
such as for example PUSH messages defined in <xref target="I-D.ietf-dnssd-push"/>. 
When a server wishes to send such queries
it MUST select the next available server stream, in conformance
with section 10.2 of <xref target="I-D.ietf-quic-transport" />. It will then send 
the DNS query over the selected stream, 
and MUST indicate through the STREAM FIN mechanism that no further data will
be sent on that stream.
</t>
<t>
The client MUST send the response on the same stream, and MUST indicate through the 
STREAM FIN mechanism mechanism that no further data will
be sent on that stream. 
</t> 
</section>

<section title="Stream Reset" anchor="quic-stream-reset" >
<t>
Stream transmission may be abandoned by either party, using the stream "reset" facility. 
A stream reset indicates that one party is unwilling to continue processing
the transaction associated with the stream. The corresponding transaction MUST be abandoned.
A Server Failure (ServFail, <xref target="RFC1035" />) SHOULD be
notified to the initiator of the transaction.
</t>
<t>
TODO: should there be timers? What if a client sends a query and the server never sends
a response?
</t>
</section>

</section> <!-- end of Stream mapping -->

<section anchor="Connection-Close" title="Closing the DNS over QUIC connection">
<t>
QUIC connections are closed using the CONNECTION_CLOSE
mechanisms specified in <xref target="I-D.ietf-quic-transport" />.
Connections can be closed at the initiative of either the client
or the server. The party initiating the connection closure
SHOULD use the QUIC GOAWAY mechanism to initiate a graceful
shutdown of a connection.
</t>
<t>
The transactions corresponding to stream number higher than indicated
in the GO AWAY frames MUST be considered failed. Similarly, if
streams are still open when the CONNECTION_CLOSE is received,
the corresponding transactions MUST be considered failed. In both cases,
a Server Failure (ServFail, <xref target="RFC1035" />) SHOULD be
notified to the initiator of the transaction.
</t>
</section>

<section anchor="Connection-resume" title="Connection Resume and 0-RTT" >
<t>
A stub resolver MAY take advantage of the connection resume
mechanisms supported by QUIC transport <xref target="I-D.ietf-quic-transport" />
and QUIC TLS <xref target="I-D.ietf-quic-tls" />. 
Stub resolvers SHOULD consider potential privacy issues associated
with session resume before deciding to use this mechanism. These privacy
issues are detailed in <xref target="session-resume-privacy" />.
</t>
<t>
When resuming a session, a stub resolver MAY take advantage of the
0-RTT mechanism supported by QUIC. The 0-RTT mechanism MUST NOT be
used to send data that is not "replayable" transactions. For example, 
a stub resolver MAY transmit a Query as 0-RTT, but MUST NOT transmit 
an Update.
</t>
</section>

</section> <!-- end of Specifications -->

<section anchor="usage-and-deployment" title="Usage and deployment" >
<t>
TODO: add deployment considerations here, such as how to provision the service,
how to verify certificates, how to manage fallbacks.
</t>


<section title="Authentication" >
<t>
We envisage using DNS over QUIC in two main scenarios, client to to recursive resolver
and recursive resolver to authoritative resolver. 
In the client to recursive resolver scenario,
the authentication requirements are the same as described in <xref target="RFC7858" /> and <xref target="I-D.ietf-dprive-dtls-and-tls-profiles" />. 
There is no need to authenticate the client's identity in either scenario.
</t>
<t>
In the recursive resolver to authoritative server scenario, the server's identity can be 
verified using the usual TLS mechanisms, using either X.509 certificate or the
DANE mechanisms <xref target="RFC6698"/>. The server's authority to provide 
answers for the client's queries can be verified using DNS Security Extensions (DNSSEC) 
<xref target="RFC4033" />, and there is not much point to replicate that mechanism using QUIC
security negotiation. 
</t>
</section>

<section anchor="fall-back" title="Fall Back to other protocols">
<t>
If the establishment of the DNS over QUIC session fails, clients
SHOULD attempt to fall back to DNS over TLS, as specified in
<xref target="RFC7858" />.
</t>

        <t>
          DNS clients SHOULD remember server IP addresses that don't
          support DNS over QUIC, including timeouts, connection
          refusals, and QUIC handshake failures, and not request
          DNS over QUIC from them for a reasonable period (such as
          one hour per server).  DNS clients following an out-of-band key-pinned
          privacy profile (<xref target="RFC7858"/>) MAY be more aggressive about retrying
          DNS-over-QUIC connection failures.
        </t>
</section>


<section anchor="Connection-Close-Usage" title="Guidance on Connection Reuse, Close, and Reestablishment">

<t>
For DNS clients that use library functions such as "getaddrinfo()" and "gethostbyname()",
current implementations are known to open and close TCP connections for each DNS
query.  To avoid excess QUIC connections, each with a single query,
clients SHOULD reuse a single QUIC connection to the
recursive resolver.  Alternatively, they may prefer to use UDP
to a DNS-over-QUIC-enabled caching resolver on the same machine
that then uses a system-wide QUIC connection to the recursive
resolver.
</t>
<t>
In order to amortize QUIC and TLS connection setup costs, clients
and servers SHOULD NOT immediately close a connection after
each response.  Instead, clients and servers SHOULD reuse
existing connections for subsequent queries as long as they
have sufficient resources.  In some cases, this means that
clients and servers may need to keep idle connections open for
some amount of time.
</t>
<t>
Proper management of established and idle connections is important
to the healthy operation of a DNS server.  An implementor of
DNS over QUIC SHOULD follow best practices for DNS over TCP, as
described in <xref target="RFC7766"/>.  Failure
to do so may lead to resource exhaustion and denial of service.
</t>
<t>
This document does not make specific recommendations for timeout
values on idle connections.  Clients and servers should reuse
and/or close connections depending on the level of available
resources.  Timeouts may be longer during periods of low activity
and shorter during periods of high activity.  Current work in
this area may also assist DNS-over-TLS clients and servers
in selecting useful timeout values <xref
target="RFC7828"/> <xref target="TDNS"/>.
</t>
<t>
Clients and servers that keep idle connections open MUST be
robust to termination of idle connection by either party.  As
with current DNS over TCP, DNS servers MAY close the connection
at any time (perhaps due to resource constraints).  As with current
DNS over TCP, clients MUST handle abrupt closes and be prepared
to reestablish connections and/or retry queries.
</t>
<t>
When reestablishing a DNS-over-QUIC connection that was terminated,
clients and servers SHOULD take advantage of the QUIC "resume"
mechanisms.   
</t>
<t>
TODO: QUIC provides an efficient mechanism for resuming connections,
including the possibility of sending 0-RTT data. Does that change
the tradeoff? Is it plausible to use shorter timers than specified 
for TCP?
</t>
</section>


</section> <!-- end of usage -->


<section title="Security Considerations">
<t>
The security considerations of DNSover QUIC should be comparable to
those of DNS over TLS <xref target="RFC7858" />.
</t>
</section>

<section title="Privacy Considerations">
<t>
QUIC over TLS is specifically designed to protect the DNS traffic between stub and resolver from
observations by third parties, and thus protect the privacy of the stub's users. However, the
recursive resolver has full visibility of the stub's traffic, and could be used as an observation
point, as discussed in <xref target="session-resolver-privacy" />. Also, the requests sent
by the stub resolver may generate corresponding requests from the recursive resolver to
authoritative servers. Adversaries can try to infer the stub to resolver traffic from their 
observation of the resolver to authoritative traffic, as disccused in 
<xref target="session-backend-privacy" />.
</t>
<t>
QUIC incorporates the mechanisms of TLS 1.3
<xref target="I-D.ietf-tls-tls13" /> and this enables QUIC enables transmission of "Zero RTT" data. 
This can provide interesting latency gains, but it raises two concerns:
<list style="numbers">
<t>
Adversaries could replay the zero-RTT data and infer its content from the behavior of 
the receiving server.
</t>
<t>
The zero-RTT mechanism relies on TLS resume, which can provide linkability between
successive client sessions.
</t>
</list>
</t>
<t>
We develop these issues in <xref target="session-0RTT-privacy" /> 
and <xref target="session-resume-privacy" />.
</t>
<section title="Privacy of Resolver Data" anchor="session-resolver-privacy" >
<t>
The recursive resolver could easily capture a log of the traffic sent by the stub resolver,
and make it available to third parties. This would negate the privacy benefits of encrypting
the data between stub and resolver.
</t>
<t>
A first mitigation against that risk is the publication by the operator of the resolver of 
a satisfactory privacy policy, explaining to potential users how the data will be protected.
For example, a resolver may decide to not keep logs or to only keep them for short periods,
and may commit to not disclose the stub's data to third parties.
</t>
<t>
A policy voluntarily adopted by the resolver may not be sufficient if adversaries manage to 
somehow gain control of the resolver, for example using some kind of computer virus. Mitigations
against such attacks will protective actions by the stubs. Stubs may for example add cover
traffic to the normal set of DNS queries, or they may split their traffic between several
resolvers. Such mitigations will require further study.
</t>
</section>
<section title="Backend observation of DNS traffic" anchor="session-backend-privacy" >
<t>
Queries sent by the stub to the recursive may be served from the recursive's cache, or
may be served by forwarding the query to an authoritative server. Adversaries could observe the
outgoing queries and try to correlate them with the encrypted traffic received by
the recursive resolver. In the extreme case of a resolver with only one active stub client,
this correlation is trivial. It gets progressively harder when resolvers serve larger 
number of clients.
</t>
<t>
Recursive resolvers MAY consider techniques like proactive caching to reduce the effectiveness 
of this attack. Stub clients MAY prefer using resolvers that manage a large number of other 
clients, as this will make the adversaries job harder. In the future, stub clients
MAY attempt to mitigate this issue by using the cover traffic and split traffic strategies 
discussed in <xref target="session-resolver-privacy" />.
</t>
</section>
<section title="Privacy Issues With 0RTT data" anchor="session-0RTT-privacy" >
<t>
The zero-RTT data can be replayed by adversaries. That data may triggers a request by a
recursive resolver to an authoritative resolvers. Adversaries may be able to pick a time 
at which the recursive resolver outgoing traffic is observable, and thus find out what name was
queried for in the 0-RTT data.
</t>
<t>
This risk is in fact a subset of the general problem of observing the behavior of the
recursive resolver discussed in <xref target="session-backend-privacy" />. The attack
is partially mitigated by reducing the observability of this traffic. However, the
risk is amplified for 0-RTT data, because the attacker might replay it at chosen times,
several times.
</t>
<t>
The recommendation in <xref target="I-D.ietf-tls-tls13" /> is that the capability
to use 0-RTT data should be turned off by default, on only enabled if the user
clearly understands the associated risks.
</t>
</section>
<section title="Privacy Issues With Session Resume" anchor="session-resume-privacy" >
<t>
The QUIC session resume mechanism reduces the cost of reestablishing sessions and enables zero-RTT data.
There is a linkability issue associated with session resume, if the same resume token
is used several times, but this risk is mitigated by the mechanisms incorporated in QUIC and in
TLS 1.3. With these mechanisms, clients and servers can cooperate to avoid
linkability by third parties. However, the server will always be able to link the resumed session 
to the initial session. This creates a virtual long duration session. The series of requests
in that section can be used by the server to identify the client.
</t>
<t>
Enabling the server to link client sessions through session resume is probably not a large
addiional risk if the client's connectivity did not change between the sessions, since the
two sessions can probably be correlated by comparing the IP addresses. On the other hand, if
the addresses did change, the client SHOULD consider whether the linkability risk
exceeds the privacy benefits. This evaluation will obviously depend on the level of trust between
stub and recursive. 
</t>
</section>

</section> <!-- end of privacy -->

<section title="IANA Considerations" anchor="iana">

<section anchor="registration-of-dnsquic-identification-string" 
title="Registration of DNS over QUIC Identification String">

<t>This document creates a new registration for the identification of DNS over QUIC in
the "Application Layer Protocol Negotiation (ALPN) Protocol IDs" registry
established in <xref target="RFC7301"/>.</t>

<t>The "dq" string identifies DNS over QUIC:</t>

<t><list style="hanging">
  <t hangText='Protocol:'>
  DNS over QUIC</t>
  <t hangText='Identification Sequence:'>
  0x64 0x71 ("dq")</t>
  <t hangText='Specification:'>
  This document</t>
</list></t>

</section>


    <section anchor="IANA-port" title="Reservation of port 953">

      <t>
        IANA is required to add the following value to the "Service Name
        and Transport Protocol Port Number Registry" in the System
        Range.  The registry for that range requires IETF Review or IESG Approval 
        <xref target="RFC6335"/>, and such a review was requested using the
        early allocation process <xref target="RFC7120"/> for the well-known TCP port
        in this document.
      </t>

    <figure>
    <artwork><![CDATA[
    Service Name           domain-s
    Port Number            953
    Transport Protocol(s)  TCP/UDP
    Assignee               IESG
    Contact                IETF Chair
    Description            DNS query-response protocol run over QUIC
    Reference              This document
      ]]></artwork>
    </figure>

    </section>

</section> <!-- end of IANA -->

<section title="Acknowledgments">
<t>
This document liberally borrows text from <xref target="I-D.ietf-quic-http" /> authored by
Mike Bishop, and from <xref target="RFC7858" /> authored by Zi Hu, Liang Zhu, John Heidemann,
Allison Mankin, Duane Wessels, and Paul Hoffman.
</t>
<t>
The privacy issue with 0-RTT data and session resume were analyzed by
Daniel Kahn Gillmor (DKG) in a message to the IETF "DPRIV" working group 
<xref target="DNS0RTT" />.
</t>
<t>
Thanks to our wide cast of supporters.
</t>
</section>
</middle>

<back>

<references title="Normative References">
       &rfc1034;
       &rfc1035;
       &rfc2119;
       &I-D.ietf-quic-transport;
       &I-D.ietf-quic-tls;
       &I-D.ietf-dprive-dtls-and-tls-profiles;
       &rfc7301;
</references>

<references title="Informative References">
      &rfc4033;
      &rfc5936;
      &rfc6335;
      &rfc6698;
      &rfc7120;
      &rfc7626;
      &rfc7828;
      &rfc7766;
      &rfc7858;
      &I-D.ietf-quic-http;
      &I-D.ietf-quic-recovery;
      &I-D.ietf-dnssd-push;
      &I-D.ietf-tls-tls13;

<reference anchor="DNS0RTT" target="https://www.ietf.org/mail-archive/web/dns-privacy/current/msg01276.html">
  <front>
    <title>DNS + 0-RTT</title>
    <author initials="D." surname="Kahn Gillmor" fullname="Daniel Kahn Gillmor">
      <organization/>
    </author>
    <date year="2016" month="April" day="06" />
  </front>
  <seriesInfo name="Message" value="DNS-Privacy WG mailing list"/>
</reference>

<reference anchor="TDNS" target="http://dx.doi.org/10.1109/SP.2015.18">
        <front>
          <title>Connection-Oriented DNS to Improve Privacy and Security</title>
          <author initials="L." surname="Zhu" fullname="Liang Zhu"/>
          <author initials="Z." surname="Hu" fullname="Zi Hu"/>
          <author initials="J." surname="Heidemann" fullname="John Heidemann"/>
          <author initials="D." surname="Wessels" fullname="Duane Wessels"/>
          <author initials="A." surname="Mankin" fullname="Allison Mankin"/>
          <author initials="N." surname="Somaiya" fullname="Nikita Somaiya"/>
          <date/>
        </front>
        <seriesInfo name="2015 IEEE Symposium" value="on Security and Privacy (SP)" />
   <seriesInfo name="DOI" value="10.1109/SP.2015.18" />
      </reference>


</references>  

</back>
</rfc>
